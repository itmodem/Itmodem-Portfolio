Great question!
When you want to **update state based on its previous value** (like incrementing a count), you should always use the **functional form of `setState()`** to avoid bugs.

---

## 🧠 **What does it mean?**

Instead of this (❌ sometimes wrong):

```js
setCount(count + 1);
```

Use this (✅ always safe):

```js
setCount(prevCount => prevCount + 1);
```

Because React state updates are **asynchronous**, using the previous value directly ensures you always get the **latest state**.

---

## ✅ Small Example: Counter Component

```jsx
import React, { useState } from 'react';

const Counter = () => {
  // Start with count = 0
  const [count, setCount] = useState(0);

  // Correctly update based on previous value
  const handleIncrement = () => {
    setCount(prevCount => prevCount + 1); // ✅ safest way
  };

  const handleDecrement = () => {
    setCount(prevCount => prevCount - 1); // ✅
  };

  return (
    <div className="p-4 text-center">
      <h2 className="text-xl font-bold">Counter: {count}</h2>
      <button onClick={handleIncrement} className="bg-green-500 text-white px-4 py-2 m-2 rounded">
        + Increment
      </button>
      <button onClick={handleDecrement} className="bg-red-500 text-white px-4 py-2 m-2 rounded">
        - Decrement
      </button>
    </div>
  );
};

export default Counter;
```

---

## 🔎 Key Line:

```js
setCount(prevCount => prevCount + 1);
```

Here:

* `prevCount` → automatically gets the **latest value**
* You're returning the **new state** based on the old one

---

## 💡 Use this pattern when:

* Incrementing/decrementing numbers
* Toggling boolean: `setShow(prev => !prev)`
* Updating objects or arrays based on previous state

---

Let me know if you want this concept in:

* 📄 Hindi explanation
* 🧪 Quiz style
* ✅ Practice challenge

Also: Want to learn **how to update an object or array state safely** next?
